{
	"commitChanges": "async function commitChanges(message) { const { exec } = require('child_process'); return new Promise((resolve, reject) => { exec(`git commit -m '${message}'`, (error, stdout, stderr) => { if (error) { reject(`Error committing changes: ${stderr}`); return; } resolve(stdout); }); }); }",
	"pushChanges": "async function pushChanges(branch = 'main') { const { exec } = require('child_process'); return new Promise((resolve, reject) => { exec(`git push origin ${branch}`, (error, stdout, stderr) => { if (error) { reject(`Error pushing changes: ${stderr}`); return; } resolve(stdout); }); }); }",
	"createTag": "async function createTag(tagName) { const { exec } = require('child_process'); return new Promise((resolve, reject) => { exec(`git tag ${tagName}`, (error, stdout, stderr) => { if (error) { reject(`Error creating tag: ${stderr}`); return; } resolve(stdout); }); }); }",
	"pushTags": "async function pushTags() { const { exec } = require('child_process'); return new Promise((resolve, reject) => { exec('git push origin --tags', (error, stdout, stderr) => { if (error) { reject(`Error pushing tags: ${stderr}`); return; } resolve(stdout); }); }); }",
	"getCurrentBranch": "async function getCurrentBranch() { const { exec } = require('child_process'); return new Promise((resolve, reject) => { exec('git rev-parse --abbrev-ref HEAD', (error, stdout, stderr) => { if (error) { reject(`Error getting current branch: ${stderr}`); return; } resolve(stdout.trim()); }); }); }",
	"checkoutBranch": "async function checkoutBranch(branch) { const { exec } = require('child_process'); return new Promise((resolve, reject) => { exec(`git checkout ${branch}`, (error, stdout, stderr) => { if (error) { reject(`Error checking out branch: ${stderr}`); return; } resolve(stdout); }); }); }"
}